![image](https://github.com/eoghks/Alice-Code-Challenge/assets/62344247/281fe51d-6f76-4d75-9546-c1bfa743806b)

---
잘못 생각한 부분이 존재하였다.
"두 사람 모두 이기기 위해 최선을 다한다."라는 제약 조건이 있었다. 
그러나, 먼저 시작한 사람이 이기기 위해 최선을 다하는 알고리즘을 짯다. 즉, 두 사람이 움직이는 위치는 다음 사람이 적은 점수를 얻도록 가장 적은 최소 값으로 움직여야했다.
또한, 결국 깊이 우선 탐색 문제로 leaf노드 부터 점수를 파악하면 된다. 
이후 각 부모 노드는 자식의 점수가 가장 낮은 점수를 찾아 이를 2번 사용자의 점수로 생각하고 자신의 점수에서 이를 빼면 부모 노드에서 게임을 햇을 때의 점수를 알 수 있다. 현재 노드가 root가 될때까지 반복하면된다.
예시 코드처럼 inf를 사용할 수 있지만 양수이면 1번 승리 음수이면 0번 승리로 파악하여 코드를 짤 수도 있을 것 같다.  
자식 노드의 값이 부모 노드의 점수와 관련되어 있으니 DP를 사용하고 leaf 노드부터 확읺을 해야하니 DFS를 활용한다는 점을 파악했다면 쉽게 풀엇을 수도 있다.  
아직 DP를 사용하는 것과 DFS를 사용하는 상황을 파악하는게 부족한것 같다. 해당 알고리즘을 사용하는 문제를 많이 풀어보고 경험을 많이 쌓을 필요가 있어 보인다.
