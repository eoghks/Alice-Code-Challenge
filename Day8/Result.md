![image](https://github.com/user-attachments/assets/c4cb5a83-782a-47f0-91e5-ee0769b5707f)

---
풀고 나서 나는 그리드 알고리즘으로 푼것을 알았다. 앞에서부터 신도 수가 부족하면 친구를 투입했는데 그게 아니라 친구를 투입해서 최대한 오래동안 엘리스가 유지되도록 해야했다. 즉 일부로 처음에 투입을 안하고 나중에 투입하는 경우도 존재하는 것이다.
--
윗 아이디어를 생각하고 이른 재귀를 통해 구현햇으나 시간 초과로 실패햇엇다. 정답 코드를 보고 분석해본 결과 내가 재귀로만 만들려던 아이디어를 dp를 더해 풀어낸것이엿다. dp를 써서 이미 구한 값을 재사용하기 때문에 시간초과가 안걸린다. 코드 풀이를 간단하게 해보자.
0. dp 생성 및 dp의 의미
<pre>
  static int[][][] dp = new int[301][301][301];
  static int[] need = new int[301];

  // dp[i][j][k] = i번째 시간에 j명의 친구가 투입되어 있으며, k명의 친구가 남은 경우 앞으로 가능한 최대 강림 시간을 
</pre>
1. 각 일 수마다 필요한 친구 수를 계산해 배열에 집어넣는다.
<pre>
  for (int i = 0; i < M; i++) {
      int a = sc.nextInt();
      int b = sc.nextInt();
      for (int j = a; j < b; j++) {
          need[j]--;
      }
  }
</pre>
2. 기저 사례를 만든다. N일에 도착했을 때 투입된 친구수가 필요한 친구 수 보다 많은 경우 1 아닌경우 0으로 초기화를 해놓으면된다.
<pre>
  for (int i = 0; i <= 300; i++) {
      for (int j = 0; j <= 300; j++) {
          if (i >= need[N]) {
              dp[N][i][j] = 1;
          } else {
              dp[N][i][j] = 0;
          }
      }
  }
</pre>
3. dp를 채우는 실제 코드이다.
   1) 기저사례(이미 구한 경우 또 구할 필요가 없다.)
  <pre>
    if (dp[x][y][z] != -1) {
        return dp[x][y][z];
    }
  </pre>
  2) 오늘도 친구가 투입 되어야 했고, 내일도 친구가 투입되어야 하는 경우 => 현재 투입된 y명으로 내일 진행
  <pre>
    if (need[x] > 0 && need[x + 1] > 0) {
        dp[x][y][z] = makeDP(x + 1, y, z);
    }
  </pre>
  3) 오늘 친구가 투입됫으나, 내일 친구들이 모두 빠지는 경우 =? 내일 친구수가 0으로 변한다.
  <pre>
    else if (need[x] > 0 && need[x + 1] <= 0) {
        dp[x][y][z] = makeDP(x + 1, 0, z);
    } 
  </pre>
  4. 오늘은 친구가 없엇으나, 내일은 친구가 투입되는 경우 => 0명부터 남은 친구인 z명까지 투입되는 모든 경우의 수에 대해 구한다.
  <pre>
    else if (need[x] <= 0 && need[x + 1] > 0) {
        for (int i = 0; i <= z; i++) {
            dp[x][y][z] = Math.max(dp[x][y][z], makeDP(x + 1, i, z - i)); //최대 강림일 수를 구해야하므로 max로 확인
        }
    }
  </pre>
  5. 오늘과 내일 모두 친구가 필요 없으나, 내일 신도 수가 T보단 작아 현재 투입 인원을 유지하는 경우
  <pre>?
    else if (need[x] <= 0 && need[x + 1] <= 0) {
        dp[x][y][z] = makeDP(x + 1, y, z);
    }
  </pre>
  6. 현재 투입된 인원이 필요한 인원보다 많으면 강림일 수 1을 더한다.
 <pre>
   if (y >= need[x]) {
      dp[x][y][z] += 1;
   }
 </pre>
---
핵심 아이디어는 친구가 필요할 때 한번 투입된 인원은 필요한 신도 수가 T보다 많아질때까지 유지한다는것이다.
dp에 대해 조금 더 연구하고 학습하여 내가 생각한 아이디어와 접목 시키는 훈련이 필요해보인다.
